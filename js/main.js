// ============================================
// VARIABLES GLOBALES
// ============================================
let workbook = null;
let hojas = {
    catalogo: [],
    inventario: [],
    compras: [],
    salidas: [],
    diario: [],
    mayor: []
};

// ============================================
// FUNCI√ìN PARA CONVERTIR FECHAS DE EXCEL
// ============================================
// ============================================
// FUNCI√ìN MEJORADA PARA PROCESAR FECHAS (VERSI√ìN DEFINITIVA)
// ============================================
function procesarFecha(fecha) {
    // Si es null, undefined o vac√≠o
    if (fecha === null || fecha === undefined || fecha === '' || fecha === 'null') {
        return null;
    }
    
    // Si ya es una cadena con formato dd/mm/yyyy o dd/mm/yy
    if (typeof fecha === 'string') {
        // Formato dd/mm/yyyy o dd/mm/yy
        if (fecha.match(/^\d{1,2}\/\d{1,2}\/\d{2,4}$/)) {
            return fecha;
        }
        
        // Formato yyyy-mm-dd (ISO)
        if (fecha.match(/^\d{4}-\d{2}-\d{2}/)) {
            const partes = fecha.split('-');
            return `${partes[2].substring(0,2)}/${partes[1]}/${partes[0]}`;
        }
        
        // Formato dd-mm-yyyy
        if (fecha.match(/^\d{1,2}-\d{1,2}-\d{4}$/)) {
            const partes = fecha.split('-');
            return `${partes[0]}/${partes[1]}/${partes[2]}`;
        }
    }
    
    // Si es un objeto Date
    if (fecha instanceof Date && !isNaN(fecha.getTime())) {
        const dia = String(fecha.getDate()).padStart(2, '0');
        const mes = String(fecha.getMonth() + 1).padStart(2, '0');
        const anio = fecha.getFullYear();
        return `${dia}/${mes}/${anio}`;
    }
    
    // Si es un n√∫mero serial de Excel (44927 = alguna fecha)
    if (typeof fecha === 'number' && fecha > 0) {
        try {
            // F√≥rmula de conversi√≥n de Excel serial date
            const excelEpoch = new Date(1899, 11, 30);
            const dias = Math.floor(fecha);
            const fechaConvertida = new Date(excelEpoch.getTime() + dias * 86400000);
            
            const dia = String(fechaConvertida.getDate()).padStart(2, '0');
            const mes = String(fechaConvertida.getMonth() + 1).padStart(2, '0');
            const anio = fechaConvertida.getFullYear();
            return `${dia}/${mes}/${anio}`;
        } catch (e) {
            console.warn('Error convirtiendo n√∫mero serial:', fecha, e);
        }
    }
    
    // √öltimo intento: intentar parsear como Date
    try {
        const d = new Date(fecha);
        if (!isNaN(d.getTime())) {
            const dia = String(d.getUTCDate()).padStart(2, '0');
            const mes = String(d.getUTCMonth() + 1).padStart(2, '0');
            const anio = d.getUTCFullYear();
            return `${dia}/${mes}/${anio}`;
        }
    } catch (e) {
        console.warn('No se pudo procesar la fecha:', fecha);
    }
    
    return null;
}

// ============================================
// üîß FUNCI√ìN DE NORMALIZACI√ìN FINAL DE FECHAS EN INVENTARIO
// ============================================
function normalizarFechasInventario() {
    hojas.inventario = hojas.inventario.map(lote => {
        const nuevo = { ...lote };

        // Detectar columnas de fecha con distintos nombres
        for (const clave in lote) {
            const key = clave.toLowerCase().replace(/\s/g, '');

            if (key.includes('fab')) {
                nuevo[clave] = procesarFecha(lote[clave]);
            }
            if (key.includes('venc')) {
                nuevo[clave] = procesarFecha(lote[clave]);
            }
        }

        return nuevo;
    });

    console.log("üßπ Fechas normalizadas en Inventario:", hojas.inventario.slice(0, 3));
}


// ============================================
// FUNCI√ìN PARA LIMPIAR NOMBRES DE COLUMNAS
// ============================================
function limpiarObjeto(obj) {
    const nuevoObj = {};
    for (let key in obj) {
        // Eliminar espacios al inicio y final del nombre de columna
        const nuevoKey = key.trim();
        nuevoObj[nuevoKey] = obj[key];
    }
    return nuevoObj;
}
// Limpia espacios invisibles, NBSP, etc.
function _cleanText(v) {
  if (v == null) return v;
  return String(v).replace(/\u00A0/g, ' ').trim();
}

// Canoniza nombres de columnas: sin acentos/espacios, min√∫sculas
function _canonKey(k) {
  return _cleanText(k)
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // sin acentos
    .replace(/[^a-zA-Z0-9]/g, '')                    // quita s√≠mbolos
    .toLowerCase();
}

// Mapea nombres ‚Äúparecidos‚Äù a los oficiales
function normalizarClavesFila(row) {
  const map = {
    // inventario
    idlote: 'ID_Lote',
    id_lote: 'ID_Lote',
    codigomed: 'C√≥digo_Med',
    codigo_med: 'C√≥digo_Med',
    nombremed: 'Nombre_Med',
    nombre_med: 'Nombre_Med',
    numlote: 'Num_Lote',
    num_lote: 'Num_Lote',
    cantinicial: 'Cant_Inicial',
    cant_inicial: 'Cant_Inicial',
    cantactual: 'Cant_Actual',
    cant_actual: 'Cant_Actual',
    fechafab: 'Fecha_Fab',
    fechafabricacion: 'Fecha_Fab',
    fecha_fab: 'Fecha_Fab',
    fechavenc: 'Fecha_Venc',
    fechavencimiento: 'Fecha_Venc',
    fecha_venc: 'Fecha_Venc',
    costounit: 'Costo_Unit',
    costo_unit: 'Costo_Unit',

    // cat√°logo
    presentacion: 'Presentaci√≥n',
    presentaci\u00F3n: 'Presentaci√≥n',
    precio_unit: 'Precio_Unit',
    precioUnit: 'Precio_Unit',
    claseabc: 'Clase_ABC',
    stockmin: 'Stock_Min',
    stockmax: 'Stock_Max',
    stockactual: 'Stock_Actual'
  };

  const out = {};
  for (const k in row) {
    const ck = _canonKey(k);
    const target = map[ck] || k.trim();
    out[target] = row[k];
  }
  return out;
}

// Conversi√≥n de fecha (string/n√∫mero/Date) a dd/mm/yyyy o null
function procesarFecha(valor) {
  if (valor == null || valor === '' || valor === 'null') return null;

  // n√∫mero serial Excel
  if (typeof valor === 'number' && isFinite(valor)) {
    const base = new Date(1899, 11, 30);
    const d = new Date(base.getTime() + Math.floor(valor) * 86400000);
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = d.getFullYear();
    return `${dd}/${mm}/${yy}`;
  }

  // texto: limpia y reconoce formatos comunes
  if (typeof valor === 'string') {
    const v = _cleanText(valor);

    // dd/mm/yyyy  √≥  d/m/yyyy
    if (/^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(v)) return v;

    // yyyy-mm-dd (ISO)
    if (/^\d{4}-\d{2}-\d{2}/.test(v)) {
      const [y,m,d] = v.split('-');
      return `${d.substring(0,2)}/${m}/${y}`;
    }

    // dd-mm-yyyy
    if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(v)) {
      const [d,m,y] = v.split('-');
      return `${d}/${m}/${y}`;
    }

    // √∫ltimo intento: Date.parse
    const tryD = new Date(v);
    if (!Number.isNaN(tryD.getTime())) {
      const dd = String(tryD.getDate()).padStart(2,'0');
      const mm = String(tryD.getMonth()+1).padStart(2,'0');
      const yy = tryD.getFullYear();
      return `${dd}/${mm}/${yy}`;
    }
  }

  // objeto Date
  if (valor instanceof Date && !Number.isNaN(valor.getTime())) {
    const dd = String(valor.getDate()).padStart(2,'0');
    const mm = String(valor.getMonth()+1).padStart(2,'0');
    const yy = valor.getFullYear();
    return `${dd}/${mm}/${yy}`;
  }

  return null;
}


// ============================================
// FUNCI√ìN PRINCIPAL: CARGAR EXCEL (VERSI√ìN FINAL)
// ============================================
function cargarArchivo() {
    const input = document.getElementById('fileInput');
    const file = input.files[0];
    
    if (!file) {
        alert('‚ö†Ô∏è Por favor selecciona un archivo Excel');
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            console.log('üìÇ Leyendo archivo...');
            
            const data = new Uint8Array(e.target.result);
            
            // LEER el workbook SIN procesar fechas a√∫n
            workbook = XLSX.read(data, {
                type: 'array',
                cellDates: false,  // NO convertir autom√°ticamente
                cellNF: false,
                cellText: false
            });
            
            console.log('üìä Hojas encontradas:', workbook.SheetNames);
            
            // Leer cada hoja SIN formateo autom√°tico
            hojas.catalogo = XLSX.utils.sheet_to_json(workbook.Sheets['Cat√°logo'], {
                raw: true,  // Obtener valores crudos
                defval: null
            });
            
            hojas.inventario = XLSX.utils.sheet_to_json(workbook.Sheets['Inventario_Lotes'], {
                raw: true,
                defval: null
            });
            
            hojas.compras = XLSX.utils.sheet_to_json(workbook.Sheets['Libro_Compras'], {
                raw: true,
                defval: null
            });
            
            hojas.salidas = XLSX.utils.sheet_to_json(workbook.Sheets['Libro_Salidas'], {
                raw: true,
                defval: null
            });
            
            hojas.diario = XLSX.utils.sheet_to_json(workbook.Sheets['Libro_Diario'], {
                raw: true,
                defval: null
            });
            
            hojas.mayor = XLSX.utils.sheet_to_json(workbook.Sheets['Libro_Mayor'], {
                raw: true,
                defval: null
            });
            
            // LIMPIAR nombres de columnas
            hojas.catalogo = hojas.catalogo.map(limpiarObjeto);
            hojas.inventario = hojas.inventario.map(limpiarObjeto);
            hojas.compras = hojas.compras.map(limpiarObjeto);
            hojas.salidas = hojas.salidas.map(limpiarObjeto);
            hojas.diario = hojas.diario.map(limpiarObjeto);
            hojas.mayor = hojas.mayor.map(limpiarObjeto);
            
            console.log('üîç Debug - Primer lote ANTES de procesar fechas:', hojas.inventario[0]);
            
            // PROCESAR fechas manualmente
            hojas.inventario = hojas.inventario.map(lote => ({
                ...lote,
                Fecha_Fab: procesarFecha(lote.Fecha_Fab),
                Fecha_Venc: procesarFecha(lote.Fecha_Venc)
            }));
            
            hojas.compras = hojas.compras.map(compra => ({
                ...compra,
                Fecha: procesarFecha(compra.Fecha)
            }));
            
            hojas.salidas = hojas.salidas.map(salida => ({
                ...salida,
                Fecha: procesarFecha(salida.Fecha)
            }));
            
            hojas.diario = hojas.diario.map(asiento => ({
                ...asiento,
                Fecha: procesarFecha(asiento.Fecha)
            }));
            // ============================================
            // Normalizar claves y convertir fechas despu√©s de leer las hojas
            // ============================================

            // 1Ô∏è‚É£ Normalizar claves de cada fila
            hojas.catalogo   = hojas.catalogo.map(normalizarClavesFila);
            hojas.inventario = hojas.inventario.map(normalizarClavesFila);
            hojas.compras    = hojas.compras.map(normalizarClavesFila);
            hojas.salidas    = hojas.salidas.map(normalizarClavesFila);
            hojas.diario     = hojas.diario.map(normalizarClavesFila);
            hojas.mayor      = hojas.mayor.map(normalizarClavesFila);

            // 2Ô∏è‚É£ Normalizar / convertir fechas
            hojas.inventario = hojas.inventario.map(l => ({
                ...l,
                Fecha_Fab:  procesarFecha(l.Fecha_Fab),
                Fecha_Venc: procesarFecha(l.Fecha_Venc)
            }));

            hojas.compras = hojas.compras.map(r => ({
                ...r,
                Fecha: procesarFecha(r.Fecha)
            }));

            hojas.salidas = hojas.salidas.map(r => ({
                ...r,
                Fecha: procesarFecha(r.Fecha)
            }));

            hojas.diario = hojas.diario.map(r => ({
                ...r,
                Fecha: procesarFecha(r.Fecha)
            }));

            // Debug para verificar fechas cargadas correctamente
            console.log('üßπ Fechas normalizadas en Inventario:',
                hojas.inventario
                    .filter(x => x.Fecha_Fab || x.Fecha_Venc)
                    .map(x => ({
                        ID_Lote: x.ID_Lote,
                        Fab: x.Fecha_Fab,
                        Venc: x.Fecha_Venc
                    }))
            );

            console.log('‚úÖ Datos cargados y procesados:');
            console.log('  - Cat√°logo:', hojas.catalogo.length, 'medicamentos');
            console.log('  - Inventario:', hojas.inventario.length, 'lotes');
            console.log('  - Compras:', hojas.compras.length, 'registros');
            console.log('  - Salidas:', hojas.salidas.length, 'registros');
            
            // Debug: Ver primer lote DESPU√âS de procesar
            console.log('‚úÖ Primer lote DESPU√âS de procesar fechas:', hojas.inventario[0]);
            
            // Debug: Ver lotes con fechas null
            const lotesConProblema = hojas.inventario.filter(l => !l.Fecha_Venc).length;
            if (lotesConProblema > 0) {
                console.warn(`‚ö†Ô∏è ${lotesConProblema} lotes sin fecha de vencimiento`);
            }
            
            // ‚≠ê RECALCULAR TODO
            recalcAll();
            actualizarLibroMayor();
            
            // Ocultar secci√≥n de carga y mostrar dashboard
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            
            // Inicializar dashboard
            mostrarDashboard();
            verificarAlertas();
            
            alert('‚úÖ Excel cargado correctamente\n' + 
                  hojas.catalogo.length + ' medicamentos\n' +
                  hojas.inventario.length + ' lotes' +
                  (lotesConProblema > 0 ? `\n\n‚ö†Ô∏è ${lotesConProblema} lotes sin fecha` : ''));
            
        } catch (error) {
            console.error('‚ùå Error al cargar Excel:', error);
            alert('‚ùå Error al cargar el archivo.\n\n' + 
                  'Verifica que:\n' +
                  '- Sea un archivo Excel (.xlsx)\n' +
                  '- Tenga todas las hojas requeridas\n' +
                  '- No est√© corrupto\n\n' +
                  'Error: ' + error.message);
        }
    };
    
    reader.readAsArrayBuffer(file);
}
// ============================================
// FUNCIONES AUXILIARES
// ============================================

function generarIDLote() {
    if (hojas.inventario.length === 0) return 'L001';
    const ultimoID = hojas.inventario[hojas.inventario.length - 1].ID_Lote;
    const numero = parseInt(ultimoID.substring(1)) + 1;
    return 'L' + numero.toString().padStart(3, '0');
}

function obtenerUltimoAsiento() {
    if (hojas.diario.length === 0) return 0;
    return Math.max(...hojas.diario.map(a => a.Num_Asiento || 0));
}

function buscarMedicamento(codigo) {
    return hojas.catalogo.find(m => m.C√≥digo === codigo);
}

function formatearFecha(v) {
  if (!v) return '‚Äî';
  // ya vienen como dd/mm/yyyy; si viniera "d/m/yyyy", pad
  const m = String(v).match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
  if (!m) return _cleanText(v); // no romper
  const dd = m[1].padStart(2,'0');
  const mm = m[2].padStart(2,'0');
  let yy = m[3];
  if (yy.length === 2) yy = (yy > '50' ? '19':'20') + yy;
  return `${dd}/${mm}/${yy}`;
}


// ============================================
// GUARDAR EXCEL ACTUALIZADO
// ============================================
function guardarExcel() {
    try {
        console.log('üíæ Guardando cambios...');
        
        // Convertir JSON de vuelta a hojas de Excel
        const ws1 = XLSX.utils.json_to_sheet(hojas.catalogo);
        const ws2 = XLSX.utils.json_to_sheet(hojas.inventario);
        const ws3 = XLSX.utils.json_to_sheet(hojas.compras);
        const ws4 = XLSX.utils.json_to_sheet(hojas.salidas);
        const ws5 = XLSX.utils.json_to_sheet(hojas.diario);
        const ws6 = XLSX.utils.json_to_sheet(hojas.mayor);
        
        // Crear nuevo workbook
        const nuevoWorkbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws1, 'Cat√°logo');
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws2, 'Inventario_Lotes');
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws3, 'Libro_Compras');
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws4, 'Libro_Salidas');
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws5, 'Libro_Diario');
        XLSX.utils.book_append_sheet(nuevoWorkbook, ws6, 'Libro_Mayor');
        
        // Generar archivo con fecha
        const fecha = new Date().toISOString().slice(0,10);
        const nombreArchivo = `inventario_minsal_${fecha}.xlsx`;
        
        XLSX.writeFile(nuevoWorkbook, nombreArchivo);
        
        console.log('‚úÖ Excel guardado:', nombreArchivo);
        alert('‚úÖ Excel guardado correctamente como:\n' + nombreArchivo);
        
    } catch (error) {
        console.error('‚ùå Error al guardar:', error);
        alert('‚ùå Error al guardar el archivo:\n' + error.message);
    }

    //Se llama a la funci√≥n del motor contable 
    recalcAll();//recalcula todo antes de guardar 
    mostrarDashboard(); //muestra el dashboard actualizado
}


// ============================================
// M√ìDULO DE REC√ÅLCULOS AUTOM√ÅTICOS
// ============================================

// 1Ô∏è‚É£ Recalcular Stock_Actual del Cat√°logo
function recalcCatalogo() {
    const stockPorMedicamento = {};

    // Sumar existencias por C√≥digo_Med en Inventario_Lotes
    hojas.inventario.forEach(lote => {
        const codigo = lote.C√≥digo_Med;
        const cantidad = parseFloat(lote.Cant_Actual || 0);
        if (!stockPorMedicamento[codigo]) stockPorMedicamento[codigo] = 0;
        stockPorMedicamento[codigo] += cantidad;
    });

    // Actualizar Stock_Actual en Cat√°logo
    hojas.catalogo = hojas.catalogo.map(med => ({
        ...med,
        Stock_Actual: stockPorMedicamento[med.C√≥digo] || 0
    }));

    console.log("‚úÖ Stock recalculado correctamente.");
}

// 2Ô∏è‚É£ Recalcular Estado de cada lote
function recalcEstadoLote() {
    const hoy = new Date();

    hojas.inventario = hojas.inventario.map(lote => {
        const cant = parseFloat(lote.Cant_Actual || 0);
        let estado = "‚úÖ Activo";

        // Si est√° agotado
        if (cant <= 0) estado = "‚ùå Agotado";

        // Validar vencimiento
        if (lote.Fecha_Venc) {
            try {
                const [d, m, a] = lote.Fecha_Venc.split("/");
                const fechaVenc = new Date(`${a}-${m}-${d}`);
                const diff = (fechaVenc - hoy) / (1000 * 60 * 60 * 24);

                if (diff <= 0) estado = "‚õî Vencido";
                else if (diff <= 30 && cant > 0) estado = "‚ö†Ô∏è Por Vencer";
            } catch {
                console.warn("‚ö†Ô∏è Fecha inv√°lida en lote:", lote.Num_Lote);
            }
        }

        return { ...lote, Estado: estado };
    });

    console.log("‚úÖ Estados de lotes actualizados.");
}

// 3Ô∏è‚É£ Funci√≥n general
function recalcAll() {
    recalcEstadoLote();
    recalcCatalogo();
    console.log("‚úÖ Recalculo completo realizado.");
}

// 4Ô∏è‚É£ Actualizar Libro Mayor
function actualizarLibroMayor() {
    console.log('üìò Actualizando Libro Mayor autom√°ticamente...');

    // 1Ô∏è‚É£ Agrupar movimientos del Libro Diario por cuenta
    const cuentas = {};

    hojas.diario.forEach(asiento => {
        const cuenta = asiento.Cuenta || 'Sin especificar';
        if (!cuentas[cuenta]) {
            cuentas[cuenta] = {
                totalDebe: 0,
                totalHaber: 0,
                movimientos: []
            };
        }

        cuentas[cuenta].movimientos.push(asiento);
        cuentas[cuenta].totalDebe += parseFloat(asiento.Debe || 0);
        cuentas[cuenta].totalHaber += parseFloat(asiento.Haber || 0);
    });

    // 2Ô∏è‚É£ Limpiar Libro Mayor anterior
    hojas.mayor = [];

    // 3Ô∏è‚É£ Registrar nuevas cuentas con sus saldos
    Object.keys(cuentas).forEach(nombreCuenta => {
        const cuenta = cuentas[nombreCuenta];
        const saldoFinal = cuenta.totalDebe - cuenta.totalHaber;

        hojas.mayor.push({
            Cuenta: nombreCuenta,
            Total_Debe: cuenta.totalDebe.toFixed(2),
            Total_Haber: cuenta.totalHaber.toFixed(2),
            Saldo_Final: saldoFinal.toFixed(2),
            Estado: saldoFinal === 0 ? '‚úîÔ∏è Balanceado' : 
                    saldoFinal > 0 ? 'üìà Deudor' : 'üìâ Acreedor'
        });
    });

    console.log('‚úÖ Libro Mayor actualizado:', hojas.mayor.length, 'cuentas procesadas');
}